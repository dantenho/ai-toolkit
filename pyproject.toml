# ============================================================================
# Python Project Configuration File (PEP 518/621 Compliant)
# ============================================================================
# This file centralizes project metadata, dependencies, and tool configurations
# following PEP 518 (build system) and PEP 621 (project metadata) standards.
# It serves as the single source of truth for package information, dependencies,
# and development tooling configuration (Ruff, MyPy, Pytest, Coverage).
#
# Workspace Setup:
# - This project uses uv for fast package management (https://github.com/astral-sh/uv)
# - Virtual environment: Created automatically by uv in .venv/ directory
# - Installation: uv sync (installs all dependencies) or uv sync --extra dev (with dev tools)
# - Package structure: Supports both src-layout (src/notebook/) and flat-layout (notebook/)
#
# GitHub CI/CD Integration:
# - CI workflows use uv for dependency management (see .github/workflows/ci.yml)
# - Ruff linting configuration is in this file (not ruff.toml) - PEP 621 compliant
# - Coverage reporting configured for pytest-cov integration
# - Type checking with MyPy in strict mode for maximum type safety
# ============================================================================

# ----------------------------------------------------------------------------
# Project Metadata (PEP 621)
# ----------------------------------------------------------------------------
# Core project information used for package distribution, PyPI publication,
# and dependency resolution by modern Python package managers (pip, uv, poetry).
[project]
# Project identifier - must be unique on PyPI, use lowercase and hyphens
name = "notebook" # Project name following PEP 423 naming conventions
# Semantic versioning: major.minor.patch
# - major: breaking changes
# - minor: new features (backward compatible)
# - patch: bug fixes (backward compatible)
version = "0.1.0" # Current project version
# Human-readable project description for PyPI and package managers
description = "Notebook project with comprehensive tooling and monitoring"
# Path to README file containing project documentation (relative to project root)
readme = "README.md"
# Minimum Python version requirement - ensures compatibility with Python 3.11+
requires-python = ">=3.11" # Python 3.11+ required for modern features
# License specification - MIT license allows permissive use and modification
license = { text = "MIT" } # Open-source MIT license
# Project authors/maintainers - used for package metadata and contact information
authors = [
    { name = "Notebook Team", email = "team@notebook.dev" }, # Primary maintainers
]
# Keywords for package discovery on PyPI and search engines
keywords = ["notebook", "python", "monitoring", "ai", "observability", "opentelemetry"]
# PyPI classifiers for project categorization - helps users find the package
classifiers = [
    "Development Status :: 3 - Alpha",                              # Project maturity level
    "Intended Audience :: Developers",                              # Target audience
    "License :: OSI Approved :: MIT License",                       # License classification
    "Programming Language :: Python :: 3",                          # Python 3 support
    "Programming Language :: Python :: 3.11",                       # Python 3.11 support
    "Programming Language :: Python :: 3.12",                       # Python 3.12 support
    "Topic :: Software Development :: Libraries :: Python Modules", # Project type
    "Topic :: System :: Monitoring",                                # Monitoring capabilities
]

# ----------------------------------------------------------------------------
# Project Dependencies
# ----------------------------------------------------------------------------
# Runtime dependencies required for the package to function.
# These are installed when the package is installed via pip/uv.
# Version constraints use semantic versioning with minimum version requirements.
dependencies = [
    # ------------------------------------------------------------------------
    # Core Framework and Server
    # ------------------------------------------------------------------------
    "fastapi>=0.104.1",          # FastAPI - Modern, fast web framework for building APIs: fastapi --> https://fastapi.tiangolo.com/    
    "uvicorn[standard]>=0.24.0", # Uvicorn - ASGI server for running FastAPI applications: uvicorn --> https://www.uvicorn.org/
    "starlette>=0.27.0",         # Starlette - Lightweight ASGI framework (FastAPI dependency)
    # ------------------------------------------------------------------------
    # HTTP and API Client Libraries
    # ------------------------------------------------------------------------
    "httpx>=0.25.0",    # HTTPX - Modern HTTP client for async requests: httpx --> https://www.python-httpx.org/
    "requests>=2.31.0", # Requests - Simple HTTP library for synchronous requests: requests --> https://requests.readthedocs.io/en/latest/
    "aiohttp>=3.9.0",   # Aiohttp - Async HTTP client/server framework: aiohttp --> https://docs.aiohttp.org/en/stable/
    # ------------------------------------------------------------------------
    # Data Validation and Serialization
    # ------------------------------------------------------------------------
    "pydantic>=2.5.0",          # Pydantic - Data validation using Python type annotations: pydantic --> https://docs.pydantic.dev/latest/
    "pydantic-settings>=2.1.0", # Pydantic Settings - Settings management using Pydantic: pydantic-settings --> https://pydantic-settings.readthedocs.io/en/latest/
    # ------------------------------------------------------------------------
    # Database and ORM
    # ------------------------------------------------------------------------
    "sqlalchemy>=2.0.23",     # SQLAlchemy - SQL toolkit and ORM: sqlalchemy --> https://www.sqlalchemy.org/ --> https://docs.sqlalchemy.org/en/latest/
    "alembic>=1.12.1",        # Alembic - Database migration tool: alembic --> https://alembic.sqlalchemy.org/en/latest/ --> https://alembic.sqlalchemy.org/en/latest/api.html
    "asyncpg>=0.29.0",        # AsyncPG - Async PostgreSQL driver: asyncpg --> https://asyncpg.readthedocs.io/en/stable/
    "psycopg2-binary>=2.9.9", # Psycopg2 - PostgreSQL adapter (synchronous): psycopg2-binary --> https://www.psycopg.org/docs/ --> https://www.psycopg.org/docs/usage.html --> https://www.psycopg.org/docs/lib/libpq-connect.html
    # ------------------------------------------------------------------------
    # Authentication and Security
    # ------------------------------------------------------------------------
    "python-jose[cryptography]>=3.3.0", # Python-JOSE - JWT implementation: python-jose[cryptography] --> https://python-jose.readthedocs.io/en/latest/jose/jwt.html
    "passlib[bcrypt]>=1.7.4",           # Passlib - Password hashing library: passlib[bcrypt] --> https://passlib.readthedocs.io/en/stable/passlib/context.html#bcrypt
    "python-multipart>=0.0.6",          # Python-Multipart - For handling file uploads: python-multipart --> https://github.com/python-multipart/python-multipart
    "cryptography>=41.0.7",             # Cryptography - Cryptographic recipes and primitives: cryptography --> https://cryptography.io/en/latest/
    # ------------------------------------------------------------------------
    # Monitoring and Observability
    # ------------------------------------------------------------------------
    "opentelemetry-api>=1.21.0",                     # OpenTelemetry API for observability instrumentation: opentelemetry-api --> https://opentelemetry-python.readthedocs.io/en/stable/api.html
    "opentelemetry-sdk>=1.21.0",                     # OpenTelemetry SDK implementation for metrics/traces; opentelemetry-sdk --> https://opentelemetry-python.readthedocs.io/en/stable/sdk.html
    "opentelemetry-instrumentation>=0.42b0",         # Auto-instrumentation for common libraries: opentelemetry-instrumentation --> https://opentelemetry-python.readthedocs.io/en/stable/instrumentation.html
    "opentelemetry-instrumentation-fastapi>=0.42b0", # FastAPI auto-instrumentation: opentelemetry-instrumentation-fastapi   --> https://opentelemetry-python.readthedocs.io/en/stable/instrumentation/fastapi.html
    "opentelemetry-exporter-prometheus>=1.12.0",     # Prometheus metrics exporter for monitoring: opentelemetry-exporter-prometheus --> https://opentelemetry-python.readthedocs.io/en/stable/exporter/prometheus.html
    "prometheus-client>=0.19.0",                     # Prometheus client library for custom metrics collection: prometheus-client --> https://prometheus.io/docs/instrumenting/client_libraries/
    "grafana-api>=1.0.3",                            # Grafana API client for programmatic dashboard management: grafana-api    --> https://grafana.com/docs/grafana/latest/http_api/
    # ------------------------------------------------------------------------
    # Web Scraping and Browser Automation
    # ------------------------------------------------------------------------
    "playwright>=1.40.0",     # Playwright for browser automation, testing, and web scraping
    "firecrawl-py>=0.0.16",   # FireCrawl Python SDK for web crawling and content extraction
    "beautifulsoup4>=4.12.2", # BeautifulSoup4 - HTML/XML parser
    "lxml>=4.9.3",            # LXML - XML and HTML parser
    # ------------------------------------------------------------------------
    # AI and Machine Learning (Core)
    # ------------------------------------------------------------------------
    "google-generativeai>=0.3.0", # Google Generative AI SDK for Gemini API integration
    "openai>=1.3.0",              # OpenAI - OpenAI API client
    "langchain>=0.1.0",           # LangChain - Framework for developing LLM applications
    # ------------------------------------------------------------------------
    # Task Queue and Background Jobs
    # ------------------------------------------------------------------------
    "celery>=5.3.4", # Celery - Distributed task queue
    "redis>=5.0.1",  # Redis - Redis client for Celery broker
    # ------------------------------------------------------------------------
    # Data Processing and Utilities
    # ------------------------------------------------------------------------
    "pandas>=2.1.3",        # Pandas - Data manipulation and analysis
    "numpy>=1.26.2",        # NumPy - Numerical computing library
    "pyyaml>=6.0.1",        # PyYAML - YAML parser and emitter
    "python-dotenv>=1.0.0", # Python-Dotenv - Load environment variables from .env files
    "toml>=0.10.2",         # TOML - TOML parser
    # ------------------------------------------------------------------------
    # Logging and Utilities
    # ------------------------------------------------------------------------
    "python-json-logger>=2.0.7", # Python-JSON-Logger - JSON formatter for Python logging
    "colorlog>=6.8.0",           # Colorlog - Colored logging output
]

# ----------------------------------------------------------------------------
# Optional Dependencies Groups
# ----------------------------------------------------------------------------
# Optional dependency groups installed via: pip install -e ".[group1,group2]"
# These allow users to install only the dependencies they need for their use case.
[project.optional-dependencies]
# Development tooling for testing, linting, formatting, and code quality
# Install with: pip install -e ".[dev]" or uv sync --extra dev
dev = [
    # Testing framework and utilities
    "pytest>=7.4.0",          # Modern Python testing framework with fixtures and plugins
    "pytest-asyncio>=0.21.0", # Async test support for testing async/await code
    "pytest-cov>=4.1.0",      # Coverage reporting plugin for pytest
    "pytest-httpx>=0.27.0",   # HTTPX test client for async HTTP request testing
    # Code formatting and style enforcement
    "black>=23.11.0", # Opinionated code formatter (backup to Ruff formatter)
    "ruff>=0.1.6",    # Fast Python linter and formatter (Rust-based, replaces multiple tools)
    # Type checking and static analysis
    "mypy>=1.7.0", # Static type checker for Python (PEP 484/526 type annotations)
    # Git hooks and pre-commit checks
    "pre-commit>=3.5.0", # Framework for managing git hooks and pre-commit checks
    # Security scanning tools
    "bandit>=1.7.5", # Security linter for Python code
    "safety>=2.3.5", # Dependency vulnerability scanner
]

# Machine Learning and Deep Learning dependencies
# Install with: pip install -e ".[ml]" or uv sync --extra ml
# Note: For GPU support, install PyTorch separately with CUDA support
ml = [
    # Core ML/DL libraries
    "torch>=2.1.0",         # PyTorch - Deep learning framework (CPU version)
    "torchvision>=0.16.0",  # TorchVision - Image and video datasets and models
    "torchaudio>=2.1.0",    # TorchAudio - Audio processing library
    "torchtext>=0.16.0",    # TorchText - Text processing utilities
    "transformers>=4.35.0", # Transformers - State-of-the-art NLP models (BERT, GPT, etc.)
    "xformers>=0.0.22",     # XFormers - Efficient Transformer implementations
    "tokenizers>=0.15.0",   # Tokenizers - Fast tokenizers for Transformers
    "accelerate>=0.25.0",   # Accelerate - Easy mixed precision and distributed training
    "datasets>=2.14.0",     # Datasets - Hugging Face datasets library
    # ONNX and Model Optimization
    "onnx>=1.15.0",          # ONNX - Open Neural Network Exchange format
    "onnxruntime>=1.16.0",   # ONNX Runtime - High-performance inference engine
    "onnxoptimizer>=0.3.13", # ONNX Optimizer - Optimize ONNX models
    "optimum>=1.14.0",       # Optimum - Optimization toolkit for Transformers
    # Data Processing and Visualization
    "matplotlib>=3.8.2",   # Matplotlib - Comprehensive plotting library
    "seaborn>=0.13.0",     # Seaborn - Statistical data visualization
    "plotly>=5.18.0",      # Plotly - Interactive plotting library
    "scikit-learn>=1.3.2", # Scikit-learn - Machine learning library
    "Pillow>=10.1.0",      # Pillow - Python Imaging Library for image processing
    "jupyter>=1.0.0",      # Jupyter - Jupyter notebook support
    "ipykernel>=6.27.0",   # IPython kernel for Jupyter
    # NVIDIA GPU Support Libraries
    "nvidia-ml-py>=12.535.0", # NVIDIA Management Library Python bindings
    "pynvml>=11.5.0",         # Python bindings for NVIDIA Management Library
]

# All dependencies (dev + ml)
# Install with: pip install -e ".[all]" or uv sync --extra all
# Note: This is a convenience group that includes all optional dependencies
all = [
    "notebook[dev,ml]", # Include all dev and ml dependencies
]

# ----------------------------------------------------------------------------
# Build System Configuration (PEP 517)
# ----------------------------------------------------------------------------
# Defines how the package should be built and which build backend to use.
# Modern Python packaging uses setuptools as the build backend with wheel support.
# Compatible with uv, pip, and other PEP 517-compliant build tools.
[build-system]
# Build dependencies required to build the package (installed in isolated build environment)
requires = [
    "setuptools>=68.0.0", # Setuptools for packaging (PEP 517 build backend)
    "wheel>=0.41.0",      # Wheel for binary distributions (modern Python packaging standard)
]
# Build backend that handles package building (setuptools PEP 517 implementation)
build-backend = "setuptools.build_meta" # Standard setuptools build backend (PEP 517 compliant)

# ----------------------------------------------------------------------------
# Package Structure Configuration
# ----------------------------------------------------------------------------
# Package discovery configuration for setuptools.
# Supports both src-layout (src/notebook/) and flat-layout (notebook/) structures.
# Update this section when the actual package structure is created.
[tool.setuptools]
# Package discovery - automatically find packages in the project
# For flat-layout (notebook/ directory at root):
packages = ["notebook"] # Package name
# Alternative: Use find directive for automatic package discovery
# packages = { find = {} } # Automatically discover all packages

# Package directory configuration (uncomment if using src-layout)
# [tool.setuptools.packages.find]
# where = ["src"] # Look for packages in src/ directory
# include = ["notebook*"] # Include packages starting with "notebook"

# ============================================================================
# Tool Configurations
# ============================================================================
# Configuration sections for development tools integrated with pyproject.toml.
# Each tool reads its configuration from [tool.<tool-name>] sections.

# ----------------------------------------------------------------------------
# Ruff Configuration - Fast Python Linting and Formatting
# ----------------------------------------------------------------------------
# Ruff is a modern, fast Python linter and formatter written in Rust.
# It replaces multiple tools: flake8, isort, black, pyupgrade, etc.
# Documentation: https://docs.astral.sh/ruff/
[tool.ruff]
# Target Python version for syntax and feature compatibility checking
target-version = "py311" # Python 3.11+ syntax and features
# Maximum line length for code formatting and linting checks
line-length = 100 # Standard line length (adjustable based on team preferences)
# Directories and files to exclude from Ruff linting and formatting
exclude = [
    ".git",          # Git repository metadata directory
    ".venv",         # Virtual environment directory (standard naming)
    "venv",          # Alternative virtual environment directory name
    "__pycache__",   # Python bytecode cache directories
    "build",         # Build artifacts directory
    "dist",          # Distribution packages directory
    ".eggs",         # Setuptools eggs directory
    "*.egg-info",    # Package metadata directories
    ".mypy_cache",   # MyPy type checking cache
    ".pytest_cache", # Pytest test cache
    ".ruff_cache",   # Ruff linting cache
]

# Ruff linting rules configuration
# Note: CI workflow checks for ruff.toml, but configuration is in pyproject.toml
# This is the recommended approach per Ruff documentation (PEP 621 compliance)
[tool.ruff.lint]
# Enable specific rule sets - comprehensive coverage of Python best practices
# These rules enforce code quality, security, and maintainability standards
select = [
    "E",   # pycodestyle errors (PEP 8 style guide violations)
    "W",   # pycodestyle warnings (style suggestions)
    "F",   # Pyflakes (logical errors and unused imports)
    "I",   # isort (import sorting and organization)
    "N",   # pep8-naming (naming convention checks)
    "UP",  # pyupgrade (modernize code to newer Python syntax)
    "B",   # flake8-bugbear (common bugs and design problems)
    "C4",  # flake8-comprehensions (comprehension optimization)
    "DTZ", # flake8-datetimez (timezone-aware datetime usage)
    "T10", # flake8-debugger (detect debugger statements)
    "EM",  # flake8-errmsg (error message best practices)
    "ISC", # flake8-implicit-str-concat (string concatenation issues)
    "ICN", # flake8-import-conventions (import style conventions)
    "PIE", # flake8-pie (miscellaneous checks)
    "PT",  # flake8-pytest-style (pytest best practices)
    "Q",   # flake8-quotes (quote style consistency)
    "RSE", # flake8-raise (exception raising best practices)
    "RET", # flake8-return (return statement best practices)
    "SIM", # flake8-simplify (code simplification opportunities)
    "TID", # flake8-tidy-imports (import organization)
    "TCH", # flake8-type-checking (type checking imports)
    "ARG", # flake8-unused-arguments (unused function arguments)
    "PTH", # flake8-use-pathlib (use pathlib instead of os.path)
    "ERA", # eradicate (detect commented-out code)
    "PD",  # pandas-vet (pandas-specific best practices)
    "PGH", # pygrep-hooks (pattern-based checks)
    "PL",  # Pylint rules (comprehensive code quality)
    "TRY", # tryceratops (exception handling best practices)
    "NPY", # NumPy-specific rules (NumPy best practices)
    "RUF", # Ruff-specific rules (Ruff's own rule set)
]
# Rules to ignore - sometimes necessary for pragmatic code decisions
ignore = [
    "E501",    # Line too long (handled by formatter, not linting)
    "PLR0913", # Too many arguments (sometimes necessary for API design)
    "PLR2004", # Magic value used in comparison (pragmatic exceptions allowed)
]

# Ruff import sorting configuration (replaces isort)
# Documentation: https://docs.astral.sh/ruff/settings/#isort
[tool.ruff.lint.isort]
# Known first-party modules - imports from these packages are sorted first
# Update this when the actual package structure is determined
known-first-party = ["notebook"] # Project package name for import organization
# Force sorting within import sections (stdlib, third-party, first-party)
force-sort-within-sections = true
# Split imports into multiple lines on trailing comma
split-on-trailing-comma = true
# Combine imports from the same module on a single line
combine-as-imports = true
# Sort imports alphabetically within each section
order-by-type = true

# Ruff code formatting configuration (replaces black)
[tool.ruff.format]
# Quote style preference - double quotes are standard in Python
quote-style = "double" # Use double quotes for strings ("example" not 'example')
# Indentation style - spaces are standard in Python (PEP 8)
indent-style = "space" # Use spaces for indentation (4 spaces per level)
# Include magic trailing comma in function calls and definitions
skip-magic-trailing-comma = false # Preserve trailing commas for better diffs
# Line ending style - auto-detect based on platform (CRLF for Windows, LF for Unix)
line-ending = "auto" # Platform-appropriate line endings

# ----------------------------------------------------------------------------
# Pytest Configuration - Testing Framework
# ----------------------------------------------------------------------------
# Pytest is the standard testing framework for Python projects.
# This configuration defines test discovery, execution options, and markers.
[tool.pytest.ini_options]
# Test discovery - directory containing test files
testpaths = ["tests"] # Look for tests in the 'tests' directory
# Test file naming patterns - pytest discovers files matching these patterns
python_files = ["test_*.py", "*_test.py"] # Files starting with 'test_' or ending with '_test.py'
# Test class naming patterns - pytest discovers classes matching this pattern
python_classes = ["Test*"] # Classes starting with 'Test' (e.g., TestMyFeature)
# Test function naming patterns - pytest discovers functions matching this pattern
python_functions = ["test_*"] # Functions starting with 'test_' (e.g., test_my_feature)
# Minimum pytest version required for these configuration options
minversion = "7.0" # Require pytest 7.0+ for modern features
# Additional pytest command-line options applied by default
addopts = [
    "-ra",                       # Show extra test summary info (short test summary info)
    "--strict-markers",          # Strict marker validation (fail on unknown markers)
    "--strict-config",           # Strict configuration validation (fail on invalid config)
    "--cov=notebook",            # Coverage analysis for 'notebook' package
    "--cov-report=html",         # Generate HTML coverage report in htmlcov/
    "--cov-report=term-missing", # Terminal coverage report showing missing lines
]
# Test markers for categorizing and filtering tests
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')", # Slow-running tests
    "integration: marks tests as integration tests",               # Integration test marker
    "unit: marks tests as unit tests",                             # Unit test marker
]

# ----------------------------------------------------------------------------
# MyPy Configuration - Static Type Checking
# ----------------------------------------------------------------------------
# MyPy performs static type checking on Python code using type annotations.
# This configuration enables strict type checking for better code quality.
[tool.mypy]
# Target Python version for type checking (must match requires-python)
python_version = "3.11" # Python 3.11 type checking
# Enable strict type checking mode - enforces comprehensive type safety
strict = true # Enable all strict type checking options (recommended for new projects)
# Warn about unused '# type: ignore' comments
warn_unused_ignores = true # Encourage removing unnecessary type ignores
# Warn about redundant type casts
warn_redundant_casts = true # Detect unnecessary type casting
# Warn about unused configuration options
warn_unused_configs = true # Alert on MyPy configuration that has no effect
# Disallow calling functions without type annotations
disallow_untyped_calls = true # Require type annotations for all function calls
# Disallow defining functions without type annotations
disallow_untyped_defs = true # Require type annotations for all function definitions
# Disallow incomplete type stubs
disallow_incomplete_defs = true # Require complete type annotations (no Any placeholders)
# Type check untyped function definitions
check_untyped_defs = true # Infer types for untyped functions and check them
# Require explicit Optional for None defaults
no_implicit_optional = true # Require Optional[T] instead of T = None
# Warn about functions returning Any type
warn_return_any = true # Alert when functions return untyped Any values
# Show error codes in MyPy output
show_error_codes = true # Display error codes (e.g., [error-code]) for easier fixing
# Support namespace packages (PEP 420)
namespace_packages = true # Enable namespace package support
# Explicit package bases - determine package base from current directory or mypy_path
explicit_package_bases = true # Help mypy correctly map file paths to module names

# ----------------------------------------------------------------------------
# Coverage Configuration - Code Coverage Analysis
# ----------------------------------------------------------------------------
# Coverage.py measures code coverage during test execution.
# This configuration defines what to measure and how to report coverage.

# Coverage.py runtime configuration
[tool.coverage.run]
# Source directories to measure coverage for
# Note: Update this when the actual package structure is created (e.g., "src/notebook" or "notebook")
# For now, configured to work with both src-layout and flat-layout package structures
source = ["notebook", "src"] # Measure coverage for the 'notebook' package (supports both layouts)
# Files and directories to omit from coverage measurement
omit = [
    "*/tests/*",       # Exclude all test files and directories
    "*/test_*.py",     # Exclude test files matching test_*.py pattern
    "*/__pycache__/*", # Exclude Python bytecode cache directories
    "*/setup.py",      # Exclude setup.py files
    "*/conftest.py",   # Exclude pytest configuration files
    "*/venv/*",        # Exclude virtual environment directories
    "*/.venv/*",       # Exclude virtual environment directories (alternative naming)
    "*/build/*",       # Exclude build artifacts
    "*/dist/*",        # Exclude distribution packages
]

# Coverage.py reporting configuration
[tool.coverage.report]
# Lines to exclude from coverage reports (regex patterns)
exclude_lines = [
    "pragma: no cover",           # Exclude lines with '# pragma: no cover' comment
    "def __repr__",               # Exclude __repr__ methods (often simple string formatting)
    "raise AssertionError",       # Exclude assertion error raises (expected in tests)
    "raise NotImplementedError",  # Exclude NotImplementedError (abstract methods)
    "if __name__ == .__main__.:", # Exclude main execution blocks (entry points)
    "if TYPE_CHECKING:",          # Exclude TYPE_CHECKING blocks (type-only imports)
    "@abstractmethod",            # Exclude abstract method decorators (must be implemented)
    "@property",                  # Exclude property decorators (simple getters often not tested)
    "if self.debug:",             # Exclude debug-only code paths
    "if settings.DEBUG",          # Exclude debug-only code paths
    "class .*\\bProtocol\\):",    # Exclude Protocol classes (structural subtyping)
    "@(abc\\.)?abstractmethod",   # Exclude abstract method decorators
]
# Minimum coverage percentage to enforce (fail if below threshold)
# Note: This is informational - actual enforcement should be in CI/CD
fail_under = 80 # Require at least 80% code coverage
